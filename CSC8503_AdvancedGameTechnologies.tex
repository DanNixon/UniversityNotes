\documentclass[a4paper]{article}
\def\DOCTITLE{CSC8503 Advanced Game Technologies}
\input{sections/preamble.tex}

% New page for each sub section
\newcommand{\subsectionbreak}{\clearpage}

\begin{document}

\tableofcontents

\vfill
Course material:
\url{https://research.ncl.ac.uk/game/mastersdegree/gametechnologies/}

\section{Physics}

\subsection{Newtonian Dynamics}

\subsubsection{Newton's First law}

\textit{In an inertial reference frame, an object either remains at rest or
continues to move at a constant velocity, unless acted upon by a force.}

\begin{itemize}
  \item
    In a games physics engine forces that would typically dampen the velocity of
    an object in motion (e.g. friction, air resistance, etc.) are abstracted to
    simple damping factors
\end{itemize}

\subsubsection{Newton's Second law}

\textit{In an inertial reference frame, the vector sum of forces on an object is
  equal to the mass of the object multiplied by the acceleration of the object.}

\[
  F = ma
\]

\subsubsection{Newton's Third law}

\textit{When one body exerts a force on a second body, the second body
  simultaneously exerts a force equal in magnitude and opposite in
direction on the first body.}

\subsubsection{Conservation of Momentum}

\textit{In a closed system, the total momentum is constant.}

\[
  p = mv
\]

In a collision:
\begin{align*}
  p^{i} &= p^{f} \\
  p^{i}_{1} + p^{i}_{2} &= p^{f}_{1} + p^{f}_{2} \\
  m^{i}_{1} v^{i}_{1} + m^{i}_{2} v^{i}_{2} &= m^{f}_{1} v^{f}_{1} + m^{f}_{2} v^{f}_{2}
\end{align*}

\subsubsection{Torque}

\begin{itemize}
  \item
    Result of a force applied to an object a given distance from a pivot point

  \item
    Torque produced by force $F$ at distance from pivot $d$: $\tau = dF$

\end{itemize}

\subsubsection{Inertia}

\begin{itemize}
  \item
    Moment of inertia is the resistance of a rigid body to change in rotational
    motion

  \item
    Moment of inertia defines how mass is distributed about each axis

  \item
    Inertial tensor contains influence of torque in a given axis on the
    acceleration in a given axis.

    \[
      \left [
        \begin{array}{c}
          \tau_{x} \\
          \tau_{y} \\
          \tau_{z}
        \end{array}
      \right ]
      =
      \left [
        \begin{array}{ccc}
          I_{xx} & I_{xy} & I_{xz} \\
          I_{yx} & I_{yy} & I_{yz} \\
          I_{zx} & I_{zy} & I_{zz}
        \end{array}
      \right ]
      \left [
        \begin{array}{c}
          \alpha_{x} \\
          \alpha_{y} \\
          \alpha_{z}
        \end{array}
      \right]
    \]

  \item
    In the inertia tensor the diagonal elements must not be zero and the
    non-diagonal elements must be symmetrical

  \item
    For symmetrical objects the inertia tensor only has non-zero elements in the
    diagonal, therefore for any given axis only torque applied in that axis can
    influence angular acceleration in that axis

  \item
    Solid sphere of radius $r$ and mass $m$:
    \begin{align*}
      i &= \frac{2mr^{2}}{5} \\
      \\
      I &= \left [
        \begin{array}{ccc}
          i & 0 & 0 \\
          0 & i & 0 \\
          0 & 0 & i
        \end{array}
      \right ]
    \end{align*}

  \item
    Solid cuboid of dimensions $(h, w, l)$ and mass $m$:
    \begin{align*}
      I_{xx} &= \frac{1}{12} m \left( h^{2} + w^{2} \right) \\
      I_{yy} &= \frac{1}{12} m \left( l^{2} + w^{2} \right) \\
      I_{zz} &= \frac{1}{12} m \left( h^{2} + l^{2} \right) \\
      \\
      I &= \left [
        \begin{array}{ccc}
          I_{xx} & 0      & 0      \\
          0      & I_{yy} & 0      \\
          0      & 0      & I_{zz}
        \end{array}
      \right ]
    \end{align*}

  \item
    Asymmetrical objects are more computationally expensive than symmetrical
    (due to non-diagonal inertia tensor) and is not always worthwhile in its
    benefit to the simulation

\end{itemize}

\subsection{Physics Engine}

\begin{itemize}
  \item
    Role of physics engine:

    \begin{enumerate}
      \item[1]
        Move objects

      \item[2]
        Detect collisions

      \item[3]
        Resolve collisions

    \end{enumerate}

\end{itemize}

\subsubsection{Orientation}

\begin{itemize}
  \item
    Stored as quaternion

  \item
    $\Theta = \left(
      xsin\left(\frac{\theta}{2}\right),
      ysin\left(\frac{\theta}{2}\right),
      zsin\left(\frac{\theta}{2}\right),
      cos\left(\frac{\theta}{2}\right)
    \right)$

    where $(x, y, z)$ is the axis of rotation and $\theta$ is the angle of
    rotation

\end{itemize}

\subsubsection{Object state}

\begin{itemize}
  \item
    Position, $s = \int v \: dt$

  \item
    Linear Velocity, $v = \int a \: dt$

  \item
    Linear Acceleration, $a = \frac{F}{m}$

  \item
    Force, $F$

  \item
    Mass, $m$

  \item
    Orientation, $\theta = \int \omega \: dt$

    (Represented as quaternion)

  \item
    Angular Velocity, $\omega = \int \alpha \: dt$

  \item
    Angular Acceleration, $\alpha = \frac{\tau}{I}$

  \item
    Torque, $\tau$

  \item
    Inertia, $I$

\end{itemize}

\subsubsection{Physics Representation}

\begin{description}
  \item[Particle] \hfill
    \begin{itemize}
      \item
        Single point in space

      \item
        Has linear motion but no angular motion

      \item
        Has no volume

      \item
        Can be used for particle systems (e.g. smoke, fog, fire, etc.) or for
        when speed of calculations is more important than physical accuracy
        (e.g.  distant objects, off camera objects, etc.)

    \end{itemize}

  \item[Rigid Body] \hfill
    \begin{itemize}
      \item
        Objects are defined as a set of shapes in space

        Complex objects built up of several individual rigid bodies

      \item
        Has linear and angular motion

      \item
        Has volume and mass

      \item
        Shape is constant/non-deformable

      \item
        Used when accurate collision detection and response is required

    \end{itemize}

  \item[Soft Body] \hfill
    \begin{itemize}
      \item
        Represents objects that can change shape/deform

      \item
        Otherwise similar to rigid body

      \item
        More expensive than rigid bodies (both computationally and memory wise)

    \end{itemize}

\end{description}

\begin{table}[]
  \centering
  \begin{tabular}{@{}llllll@{}}
    \toprule
               & Velocity   & Angular    & Volume     & Deformation & Collision    \\
    \midrule
    Particle   & \checkmark & \crossmark & \crossmark & \crossmark  & (\crossmark) \\
    Rigid Body & \checkmark & \checkmark & \checkmark & \crossmark  & (\checkmark) \\
    Soft Body  & \checkmark & \checkmark & \checkmark & \checkmark  & (\checkmark) \\
    \bottomrule
  \end{tabular}
  \label{tab:physical_representation_comparison}
  \caption{Comparison of features of different physical representations}
\end{table}
\FloatBarrier

\begin{itemize}
  \item
    Physics shapes are often different from graphical shapes

  \item
    Physical shape of an object is often an approximation made from several
    small shapes that provides collision detection and response that is
    sufficiently believable for the player

\end{itemize}

\subsubsection{Environment Scaling}

\begin{itemize}
  \item
    Environment scaling is important in ensuring physical accuracy in the system

  \item
    Time step must be small enough to ensure that interfaces between objects are
    detected in a timely manner

  \item
    Too slow a time step, too high a speed or too small a object can all lead to
    interfaces being detected incorrectly (either not at all or with incorrect
    normal and penetration depth)

  \item
    Use of a common scaling system (i.e. not relative to the object (or mesh))

\end{itemize}

\subsection{Numerical integration}

\begin{itemize}
  \item
    Obtaining new value based on its rate of change

  \item
    Multiple uses other than physics simulation

\end{itemize}

\subsubsection{Explicit Euler}

\begin{align*}
  v_{n + 1} &= v_{n} + a_{n} \Delta t \\
  s_{n + 1} &= s_{n} + v_{n} \Delta t
\end{align*}

\begin{itemize}
  \item
    Evaluates entirely within current time step

  \item
    Tends to be unstable unless a very short time step is used

\end{itemize}

\subsubsection{Implicit Euler}

\begin{align*}
  v_{n + 1} &= v_{n} + a_{n + 1} \Delta t \\
  s_{n + 1} &= s_{n} + v_{n + 1} \Delta t
\end{align*}

\begin{itemize}
  \item
    Addresses approximation issues of Explicit Euler by using future state of
    system

  \item
    Knowing future value of acceleration is expensive (to the extent of not
    typically being useful)

\end{itemize}

\subsubsection{Semi-implicit Euler}

\begin{align*}
  v_{n + 1} &= v_{n} + a_{n} \Delta t \\
  s_{n + 1} &= s_{n} + v_{n + 1} \Delta t
\end{align*}

\begin{itemize}
  \item
    Best of both explicit and implicit Euler

  \item
    Uses current acceleration but next velocity

  \item
    Still fast to execute but more stable than explicit Euler

\end{itemize}

\subsubsection{Verlet}

\begin{align*}
  v_{n} &= \frac{s_{n} - s_{n - 1}}{\Delta t} \\
  s_{n + 1} &= s_{n} + v_{n} \Delta t + a_{n} \Delta t^{2}
\end{align*}

\begin{itemize}
  \item
    Does not calculate velocity

  \item
    Second derivative approach

  \item
    Similar computational cost to semi-implicit Euler

  \item
    Can reverse simulation

  \item
    More suited to the penalty method of collision response

  \item
    Requires the initial state to be provided (requires last two positions)

\end{itemize}

\subsubsection{Runge-Kutta (Midpoint) method}

\begin{itemize}
  \item
    Euler methods overlook the change in velocity that occurs throughout a time
    step and only consider the values at the start and end of a step

  \item
    Runge-Kutta methods take changes in velocity during the time step into
    account via several iterations of Euler integrations

  \item
    In RK2 the velocity is predicted at the point half way through the time step
    \[
      s_{n + 1} = s_{n} + v_{n + 0.5} \Delta t
    \]

\end{itemize}

\subsubsection{Other methods}

\begin{itemize}
  \item
    Several more complex iterative integration methods exist

    (e.g. higher orders of Runge-Kutta)

  \item
    Additional accuracy of more complex integration will likely not be noticed
    in gaming physics simulations

  \item
    Better suited for mathematics, engineering and scientific simulations where
    there is a weaker real time constraint or lower agent simulations

\end{itemize}

\subsection{Constraints}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsection{Collision Detection}

\begin{itemize}
  \item
    TODO

  \item
    Collision response data to be extracted from collision detection:
    \begin{description}
      \item[Penetration Depth, $p$] \hfill \\
        Distance the two objects interface/overlap

      \item[Collision Normal, $N$] \hfill \\
        Normal along which the two objects collided

      \item[Contact Point, $P$] \hfill \\
        The point at which the two objects are interfacing

    \end{description}

\end{itemize}

\subsubsection{Sphere-Sphere test}

\begin{itemize}
  \item
    Two spheres of radii $r_{1}$ and $r_{2}$ at positions $S_{1}$ and $S_{2}$
    have collided if:
    \begin{align*}
      d &< r_{1} + r_{2} \\
      d &= \sqrt{(x_{2} - x_{1})^{2} + (y_{2} - y_{1})^{2} + (z_{2} - z_{1})^{2}}
    \end{align*}
    where $d$ is the distance between the circle centres.

  \item
    For computational savings can be simplified to:
    \begin{align*}
      d^{2} &< (r_{1} + r_{2})^{2} \\
      d^{2} &= (x_{2} - x_{1})^{2} + (y_{2} - y_{1})^{2} + (z_{2} - z_{1})^{2}
    \end{align*}

  \item
    Collision response data:
    \begin{align*}
      p &= r_{1} + r_{2} - d \\
      N &= |S_{1} - S_{2}| \\
      P &= S_{1} - N(r_{1} - p)
    \end{align*}

\end{itemize}

\subsubsection{AABB-AABB test}

\begin{itemize}
  \item
    Two AABB of dimensions $(w_{1}, h_{1}, l_{1})$ and $(w_{2}, h_{2}, l_{2})$
    at positions $(x_{1}, y_{1}, l_{2})$ and $(x_{2}, y_{2}, z_{2})$ are
    interfacing the three conditions are all true:
    \begin{align*}
      |x_{2} - x_{1}| &< \frac{1}{2}(w_{1} + w_{2}) \\
      |y_{2} - y_{1}| &< \frac{1}{2}(h_{1} + h_{2}) \\
      |z_{2} - z_{1}| &< \frac{1}{2}(l_{1} + l_{2})
    \end{align*}

  \item
    Computationally cheap, but limited as bounding boxes must be axis aligned

\end{itemize}

\subsubsection{Sphere-Plane test}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsubsection{TODO}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsection{Collision Manifolds}

\begin{itemize}
  \item
    Specify multiple points of contact for an interface rather than just one

  \item
    Manifold is summation of surface area between two colliding objects

\end{itemize}

\subsubsection{Clipping method}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsection{Collision Response}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsection{Solvers}

\begin{itemize}
  \item
    TODO

\end{itemize}

\section{Artificial Intelligence}

\subsection{Finite State Machine}

\begin{itemize}
  \item
    Implementation types:

    \begin{description}
      \item[Hard coded switch statements] \hfill \\
        \begin{itemize}
          \item
            Switch case controlling state behaviours and test for state transfer

          \item
            OK for fast prototyping but is unmanageable for a large/complex state
            machine

          \item
            Relatively computationally fast

        \end{itemize}

      \item[Hard coded state pattern] \hfill \\
        \begin{itemize}
          \item
            Each state is a data type that contains the transfer tests and
            behaviours

          \item
            Allows addition, removal and modification of states without the risk
            of invalidating the rest of the FSM

        \end{itemize}

      \item[Interpreted state pattern] \hfill \\
        \begin{itemize}
          \item
            Similar to hard coded state patterns

          \item
            States, behaviours and transfer conditions populated dynamically

            e.g. from definition files or scripts

        \end{itemize}

    \end{description}

  \item
    State diagrams often used in design of an FSM

    \begin{description}
      \item[States] \hfill
        \begin{itemize}
          \item
            Represented as nodes

          \item
            Shows the state and possibly actions

        \end{itemize}

      \item[Transitions] \hfill
        \begin{itemize}
          \item
            Represented as edges

          \item
            Shows the possible transfers between states

        \end{itemize}

      \item[Transfer conditions] \hfill
        \begin{itemize}
          \item
            Represented as edge labels

          \item
            Shows the conditions required for a transition to take place

        \end{itemize}

    \end{description}

  \item
    When designing an FSM need to take into account possibility of state
    oscillations and add hysteresis to transfer conditions where appropriate

\end{itemize}

\subsubsection{Hierarchical FSM}

\begin{itemize}
  \item
    Hierarchical FSMs allow more complex state machines and AI behaviour to be
    created

  \item
    Essentially adding another FSM as a node in a parent FSM

\end{itemize}

\subsubsection{Behaviours and Types}

\begin{itemize}
  \item
    AI types can be used to define an AI for a specific type of agent

  \item
    Types are defined by a combination of behaviours (an individual state
    machine)

  \item
    Allows for easy scaling and reuse of AI functionality

\end{itemize}

\subsubsection{Fuzzy State Machines}

\begin{itemize}
  \item
    State machine that can combine the behaviours of multiple states

  \item
    States not restricted to being either active or inactive

    Can be a certain degree of active

  \item
    Can reduce the complexity of a state machine by allowing multiple states to
    be active, therefore fewer states need to exist

  \item
    State transfer tests may be more complex to implement

\end{itemize}

\subsection{Path Planning}

\begin{itemize}
  \item
    Represent environment as a graph
    \begin{itemize}
      \item
        Waypoint are nodes

      \item
        Path between waypoints are edges

    \end{itemize}

  \item
    Nodes can be arranged in a regular pattern or in an environment specific
    manner (e.g. junctions are nodes and roads are edges)

  \item
    More sophisticated approach is to use a navigation mesh, in which nodes
    bound regions based on the shape of the environment

  \item
    Edges are weighted to represent the difficulty of traversing between two
    waypoints

  \item
    For navigation alone the data required for each node is:
    \begin{itemize}
      \item
        Unique ID

      \item
        List of connected nodes

      \item
        Position

      \item
        Passibility flag

    \end{itemize}

  \item
    Environment can be represented in any way as long as the important
    information above is included in the representation

\end{itemize}

\subsubsection{A* algorithm}

\begin{itemize}
  \item
    Based on a heuristic for the cost of traversing from a given node to the
    target node

  \item
    $f = g + h$

    $f$ is the total cost for the node under consideration

    $g$ is the cost of the shortest path from the start node to the current node

    $h$ is the estimated cost of the path from this node to the end node

  \item
    This \textbf{must} be either an underestimate or the exact cost

    Providing a heuristic that is an overestimate will result in a path other
    than the optimal path being found

  \item
    The A* algorithm maintains two lists of nodes:
    \begin{description}
      \item[Open list] \hfill \\
        \begin{itemize}
          \item
            Nodes that algorithm is aware of but not yet explored

          \item
            Have a computed $f$ value

        \end{itemize}

      \item[Closed list] \hfill \\
        \begin{itemize}
          \item
            Nodes that have been explored

          \item
            All nodes in closed list have been moved from open list

          \item
            Final path is constructed from nodes in the closed list

        \end{itemize}

    \end{description}

  \item
    A* also requires storing a reference to a parent node in each node

    Parent node is used to denote the parent which gives the shortest path back
    to the start node from any given node on the open and closed lists

  \item
    The workflow of the algorithm is as follows:
    \begin{enumerate}
      \item[1]
        Add start node to the open list

      \item[2]
        For each node P on the open list

        \begin{enumerate}
          \item[1]
            Move P to the closed list

          \item[2]
            If P is the end node the shortest path has been found, then break
            from the loop

          \item[3]
            For each node Q connected to P

          \begin{enumerate}
            \item[1]
              Skip Q if it is not traversable

            \item[2]
              Calculate $g$ and $f$ scores for Q

            \item[3]
              If Q is on either the open list or closed list and the calculated
              $g$-value is less than its current $g$-value then update the $g$
              and $f$ scores and set its parent to P

            \item[4]
              If Q is not on any list then add it to the open list and set its
              parent to P

          \end{enumerate}

        \end{enumerate}

      \item[4]
        If a path has been found the build the path by traversing the parents of
        the last node added to the closed list adding each node to a list, then
        reversing this list to obtain the path from start to end

    \end{enumerate}

\end{itemize}

\subsubsection{Computational cost}

\begin{itemize}
  \item
    Environment representation can be very memory costly for complex terrains

  \item
    Dynamic terrains will require the navigation map to be updated whenever the
    environment changes

  \item
    Dynamic loading can make memory management for the navigation graph more
    complex

  \item
    Path finding is often very computationally expensive especially with a high
    number of possible unique paths

  \item
    Path finding calculations are often not timing critical and can be split
    over frames and cores as available

  \item
    The use of a heuristic path planner should be assessed and avoided if
    possible

  \item
    Can use a hierarchical navigation graph to split up large environments

  \item
    Commonly used or high level (in a hierarchical approach) paths may be
    precomputed

\end{itemize}

\subsection{Crowd management}

\begin{itemize}
  \item
    Simply using A* for every agent is a large scale simulation is not possible:
    \begin{itemize}
      \item
        Computationally expensive

      \item
        Not guaranteed to be correct

        Multiple agents may end up attempting to take the same path at the same
        time

    \end{itemize}

  \item
    Crowd navigation focuses on managing the flow of a large number of agents
    such that they tend towards a direction rather then following an exact path

  \item
    Tend to reuse the same data used in path finding

\end{itemize}

\subsubsection{Fixed Group}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsubsection{Embedded Map Data}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsubsection{Flocking}

\begin{itemize}
  \item
    TODO

\end{itemize}

\subsubsection{Ant Colony Optimisation}

\begin{itemize}
  \item
    TODO

\end{itemize}

\section{Networking}

\subsection{Socket protocols}

\begin{description}
  \item[Stream (TCP)] \hfill \\
    \begin{itemize}
      \item
        Packets are received in order

      \item
        Reliable packet delivery

      \item
        Slower

      \item
        Better suited for transport of "important" data

        e.g. leaderboard data, in game transactions, etc

    \end{itemize}

  \item[Datagram (UDP)] \hfill \\
    \begin{itemize}
      \item
        No guaranteed order

      \item
        No guaranteed delivery

      \item
        Faster

      \item
        Better suited for frequent, time critical updates

        e.g. updating player positions in a game, etc

    \end{itemize}

\end{description}

\subsection{Topologies}

\begin{description}
  \item[Client-Server] \hfill \\
    \begin{itemize}
      \item
        Clients connect to a managed server

      \item
        Can guarantee behaviour of server

      \item
        Can cause bandwidth issues if player is far from server geographically

    \end{itemize}

  \item[Client-Client/Server] \hfill \\
    \begin{itemize}
      \item
        Clients connect to another client running as a server

      \item
        Still requires some kind of discovery service (e.g. through a managed
        server that only has this role)

      \item
        Can help to reduce bandwidth issues caused by geolocation

    \end{itemize}

  \item[Peer-peer] \hfill \\
    \begin{itemize}
      \item
        Clients connect direct to one another

      \item
        Still requires some kind of discovery service (e.g. through a managed
        server that only has this role)

      \item
        Can help to reduce bandwidth issues caused by geolocation

    \end{itemize}

\end{description}

\subsection{TODO}

\begin{itemize}
  \item
    TODO
\end{itemize}

\section{Massively parallel and Heterogeneous computing}

\begin{itemize}
  \item
    TODO

\end{itemize}

\end{document}
