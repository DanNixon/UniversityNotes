\documentclass[a4paper]{article}
\def\DOCTITLE{CSC3222 Gaming Simulations}
\input{sections/preamble.tex}

\begin{document}

\tableofcontents

\section{Equations and their Solutions}
\label{sec:equations_and_their_solutions}

\subsection{Newton's First Law}

\textit{When viewed in an inertial reference frame, an object is either at rest
or moves at a constant velocity, unless acted upon by an external force.}

\begin{itemize}
  \item
    Objects in a scene that are to be kept in a constant position (e.g. ground)
    should be immune to physics calculations.

  \item
    Movable objects should have a "rest" state in which no physics calculations
    are performed for that object until something will cause it to move.

    This both makes the simulation less computationally intensive and reduced
    the chance of jitter and error caused by two nearly equal floating point
    numbers.
\end{itemize}

\subsection{Newton's Second Law}

\textit{The vector sum of the forces acting on an object is equal to the total
mass of that object multiplied by the acceleration of the object.}

\[
  F = ma
\]

\subsection{Newton's Third Law}

\textit{When one body exerts a force on a second body, the second body
simultaniously exerts a force equal in magnitude and opposite in direction to
that of the first body.}

\subsection{Law of Conservation of Momentum}

\textit{In a closed system, total momentum is consistent.}

\[
  p = mv
\]

Ignoring all other forces if two objects of mass $m_{n}$ travelling towards each
other with momentum $u_{n}$, the total momentum of the system is:
\[
  p_{initial} = m_{1}u_{1} + m_{2}u_{2}
\]

After they collide the two objects will have two new velocities while keeping
the same masses:
\begin{align*}
  p_{final} &= m_{1}v_{1} + m_{2}v_{2} \\
  p_{final} &= p_{initial}
\end{align*}

\subsection{SUVAT equations}

\begin{description}
  \item[$s$] Displacement
  \item[$u$] Initial velocity
  \item[$v$] Final velocity
  \item[$a$] Acceleration
  \item[$t$] Time
\end{description}

\begin{align*}
      v &= u + at \\
      s &= ut + \frac{1}{2}at^{2} \\
      s &= \frac{1}{2} \left(u + v\right) t \\
  v^{2} &= u^{2} + 2as \\
      s &= vt - \frac{1}{2}at^{2}
\end{align*}

Constant acceleration is assumed, this is not an issue in simulation as updates
are calculated in time steps sufficiently small that constant acceleration can
be assumed.

\subsection{Numerical Integration}

Using time step: $\Delta t = t_{x + 1} - t_{x}$

\subsubsection{Explicit Euler}

\begin{itemize}
  \item Simple
  \item Computationally cheap
  \item Unstable at high $\Delta t$
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x} \Delta t
\end{align*}

\subsubsection{Implicit Euler}

\begin{itemize}
  \item Similar to explicit Euler but uses rate of change in next state
  \item Stable
  \item Computationally expensive
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x + 1} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t
\end{align*}

\subsubsection{Semi-implicit Euler}

\begin{itemize}
  \item A combination of explicit and implicit Euler
  \item Stable
  \item Avoid expensive operations
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t
\end{align*}

\subsubsection{Verlet}

\begin{itemize}
  \item Similar computational cost to Semi-implicit Euler
  \item Entities must store their historical positions (in a FIFO buffer)
  \item Reversible
\end{itemize}

Substitute $v = u + at$ into Euler equations:
\begin{align*}
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t \\
            &= s_{x} + (v_{x} + a_{x} \Delta t) \Delta t \\
            &= s_{x} + v_{x} \Delta t + a_{x} \Delta t^{2}
\end{align*}

This can be solved for $v_{x}$ using the past two displacements:
\begin{align*}
  v_{x} &= \frac{s_{x} - s_{x - 1}}{\Delta t}
\end{align*}

The substituted back into:
\begin{align*}
  s_{x + 1} &= s_{x} + v_{x} \Delta t + a_{x} \Delta t^{2} \\
            &= s_{x} + (s_{x} - s_{x - 1}) + a_{x} \Delta t^{2}
\end{align*}

\subsection{Drag}

In simple simulations the forces that act against an object to eventually bring
it to a stop (e.g. friction, air resistance, etc.) can be represented by a
damping factor $0 < d < 1$.

This factor is used to attenuate the velocity of a moving entity in each physics
frame.

This factor can be varied as a cheap way of simulating different environments.

\subsection{Rest}

When the velocity of an entity is close to zero, set the velocity to zero.

This is done to avoid excessive computation for entities at rest.

\subsection{Gravity}

Gravity is simple to handle as a constant that is added to acceleration in the
$y$ axis.

This constant can be varied as a cheap way of simulating different environments.

\section{Collision Detection and Response}
\label{sec:collision_detection_and_response}

\subsection{Detection}

Collision detection is a naturally expensive operation for scenes with large
numbers of entities.

Without optimisation it becomes an $N^{2}$ problem (where $N$ is the number of
entities).

An approach to reducing the number of comparison operations is to separate
collision detection into two phases: broadphase and narrowphase.

\subsubsection{Broadphase}

Broadphase collision detection reduces the number of collision checks required
by culling checks for entities that cannot have collided.

\Para{Bounding Box Test}

Tests for collisions using a bounding box defined by the extremes of an entity
in each axis.

In the case where there is no other entity "close" to the one being tested, this
replaces the complex collision check with a much simpler one.

Works well in scenes with low numbers of entities.

\Para{World Partitioning}

Partition the world into several subsections, converting the large $N^{2}$
problem into several smaller $n^{2}$ problems.

Provision has to be made for an entity to exist in multiple partitions if it is
on a boundary.

Entities are sorted into partitions based on their size and position.

If performing a simple geographical division then it is possible for the
distribution of entities to mean this is no faster (or sometimes slower) than
performing a bounding box check (e.g. if all entities are in the same
partition).

\Para{Binary Search Partitioning}

Binary search partitioning (BSP) solves the problem of uneven entity
distribution in world partitioning by recursively subdividing partitions based
on the number of entities in a partition.

An Octree is a common approach to this in which the world is split into
progressively smaller cubes.

The world is split into several partitions, if the number of entities in a
partition is above a set threshold then the partition is split into several sub
partitions. This process repeats until the number of entities in each sub
partition is below the set threshold.

The threshold must be chosen well: too high and the benefits of BSP are not
visible, too low and the process becomes inefficient due to the number of
sorting operations when partitions are divided.

\Para{Sort and Sweep}

Sort and sweep can be used in conjunction with any other method of culling
checks where collision is impossible.

In this process bounding boxes of all entities are projected onto a single axis
and any pairs of entities that do not overlap are culled from more expensive
comparisons.

This can be performed during the test for partition occupancy in world
partitioning or BSP.

\subsubsection{Narrowphase}

Accurately check the remaining pairs of entities.

Narrowphase checks should also provide the necessary data to calculate the
collision response:

\begin{description}
  \item[Contact point: $P$] \hfill \\
    Point at which the interface was detected.
  \item[Contact normal: $N$] \hfill \\
    A unit vector describing the direction in which the entities must be moved
    to resolve the interface.
  \item[Penetration depth: $p$] \hfill \\
    The minimum distance the entities must be moved to resolve the interface,
    i.e. the distance required for them to be touching, not intersecting.
\end{description}

Due to the mature of the time stepped physics model, entities will intersect
(interface) before they are detected. i.e. Collisions are not detected,
intersections are.

The time step must be small enough such that the contact point is on the correct
side of both entities, otherwise the interface will be resolved in the opposite
direction.

\Para{Sphere-Sphere detection}

Two spheres are said to have collided if the following equation is true:
\[
  d < r_{1} + r_{2}
\]

Where $d$ is the distance between the centres of the spheres and $r_{1}$ and
$r_{2}$ are the radii of each sphere.

The collision response data can be extracted as follows:
\begin{align*}
  p &= r_{1} + r_{2} - d \\
  N &= |S_{1} - S_{2}| \\
  P &= S_{1} - N \times (r_{1} - p)
\end{align*}

\Para{Sphere-Plane detection}

Using the plane equation:
\begin{align*}
  ax + by + cz + d &= 0 \\
  - ax_{0} - by_{0} - cx_{0} &\equiv d
\end{align*}

Where $N = {a, b, c}$ is the normal to the plane, $(x_{0}, y_{0}, z_{0})$ is a
point on the plane and any given point on the plane is given by $(x, y, z)$.

A sphere and plane are said to have collided if the following equation is true:
\[
  N \cdot S + d < r
\]

Where $N$ is the normal to the plane, $S$ is the position of the sphere, $d$ is
the distance from the centre of the sphere to the nearest point on the plane and
$r$ is the radius of the sphere.

The distance $d$ can be calculated by:
\[
  d = -(x \cdot N)
\]

Where $x$ is any point on the plane.

The collision response data can be extracted as follows:
\begin{align*}
  p &= r - (N \cdot S + d) \\
  P &= S - N \times (r - p)
\end{align*}

Note that in this case an infinite plane is assumed.

\subsection{Response}

Three methods:
\begin{description}
  \item[Projection] \hfill \\
    Moves colliding objects far enough apart for them not to be colliding,
    operating on position alone.
  \item[Impulse] \hfill \\
    Calculates new velocity for each object based on the law of conservation of
    momentum.
  \item[Penalty] \hfill \\
    Calculates new acceleration for each object by applying force required to
    push objects apart.
\end{description}

\subsubsection{Impulse method}

Impulse $J$ is the force $F$ applied over a time $\Delta t$.

\begin{align*}
  J &= F \Delta t \\
  J &= ma \Delta t \tag*{$F = ma$} \\
  J &= m \frac{\Delta v}{\Delta t} \Delta t = m \Delta v
    \tag*{$a = \Delta v / \Delta t$} \\
\end{align*}

As momentum $p = mv$, impulse $J$ is simply the change in momentum for an object
of constant mass.

For two colliding objects $A$ and $B$, the velocity is given by:
\begin{align*}
  v_{ab} &= v_{a} + v_{b} \\
   v_{N} &= v_{ab} \cdot N
\end{align*}

Where $v_{N}$ is the total velocity in the direction of the collision normal
$N$.

The final velocity along the normal after the collision is proportional to the
coefficient of elasticity $\epsilon$. Where $\epsilon = 1$ is an elastic
collision (i.e. all momentum is conserved) and $\epsilon = 0$ is an inelastic
collision (i.e. all momentum is dissipated).
\begin{align*}
  v_{N}^{final} &= - \epsilon \: v_{N}^{initial} \\
  (v_{a}^{final} + v_{b}^{final}) \cdot N &=
    - \epsilon \: \left(v_{a}^{initial} + v_{b}^{initial}\right) \cdot N
\end{align*}

Momentum injected into the system must be balanced to maintain the law of
conservation of momentum:
\begin{align*}
  m_{a} v_{a}^{final} &= m_{a} v_{a}^{initial} + J_{N} \\
  m_{b} v_{b}^{final} &= m_{b} v_{b}^{initial} - J_{N}
\end{align*}

The impulse $J$ is given by:
\[
  J = \frac{-\left(1 + \epsilon \right) v_{ab} \cdot N}
           {N \cdot N \left(\frac{1}{m_{a}} + \frac{1}{m_{b}}\right)}
\]

Then the new velocities for each object are computed by:
\begin{align*}
  v_{a}^{final} &= v_{a}^{initial} + \frac{J}{m_{a}} N \\
  v_{b}^{final} &= v_{b}^{initial} - \frac{J}{m_{b}} N
\end{align*}

\subsubsection{Penalty method}

See Springs first (\ref{sec:springs}).

Assume that:
\begin{itemize}
  \item A "virtual" spring exists between the colliding objects
  \item The penetration depth $p$ is the displacement of the spring
\end{itemize}

Then the relative velocity of the colliding objects is given as:
\[
  v = N \cdot (v_{a} - v_{b})
\]

Therefore the collision can be modelled as a spring using equation:
\[
  F = -kp - c \left(N \cdot (v_{a} - v_{b})\right)
\]

This calculates the resultant force of the collision, the new acceleration
values are then calculated by:
\begin{align*}
  a_{a}^{final} &= a_{a}^{initial} + \frac{F}{m_{a}} \\
  a_{b}^{final} &= a_{b}^{initial} + \frac{F}{m_{b}}
\end{align*}

The value of $k$ behaves in the same way as that of $\epsilon$ in the impulse
method.

The value of $c$ determines how much the object reacts to the spring, i.e. a
higher value gives a more "bouncy" collision.

\section{Springs}
\label{sec:springs}

A spring has rest length to which it will return when any force compressing or
extending it has been removed.

The force required to displace a spring by distance $x$ from its rest length is
given by Hooke's law of Elasticity:
\[
  F = -kx
\]

Where $k$ is the spring constant.

In a simulation an additional damping factor is added to ensure that objects
affected by the spring eventually come to rest:
\[
  F = -kx - cv
\]

Where $c$ is a damping factor and $v$ is the velocity of an object in the axis
of the spring.

\section{Soft Bodies}
\label{sec:soft_bodies}

Soft bodies (such as cloth) are modelled as a collection of rigid bodies bound
by "virtual" springs.

A piece of cloth at rest will have no tension in all springs (i.e. all springs
at their rest length), when it is moved the springs closest to the point at
which the cloth is being moved will begin to act upon their neighbouring meshes
which populates back to almost all of the surface.

Simulating soft bodies using springs can lead to amplification of movement
within the system if damping factors are not properly tuned.

\section{Choice and States}
\label{sec:choice_and_states}

Game AI is described as any decision making process within the game and is
typically implemented using a finite state machine (FSM).

An FSM is a collection of states that describe what an entity is supposed to be
doing and a set of conditions that will cause a transition to another state.

\subsection{Implementation methods}

\begin{description}
  \item[Hard coded switch] \hfill \\
    States are enumerated and transition conditions are checked based on the
    current state in a single conditional structure.

    Simple and efficient for small FSMs, becomes unmanageable for a larger/more
    complex FSM.

  \item[Hard coded state pattern] \hfill \\
    All states are child classes of a base class \texttt{State}, each state
    class is responsible for managing its own behaviour and state.

    Reduces complexity of large conditional structures.

  \item[Interpreted state pattern] \hfill \\
    Similar to above but states, behaviours and transitions are read from a file
    and the structure is constructed at game startup.

\end{description}

\subsection{Issues}

\begin{description}
  \item[Missed transitions] \hfill \\
    If the logical conditions for a state transition do not evaluate to true,
    however the transition should have happened.

    E.g. comparison using equality at a spatial boundary.

  \item[Complexity] \hfill \\
    A growing number of states can make an FSM complex, this issue is partially
    negated by hierarchical FSMs.

  \item[State oscillations] \hfill \\
    Occurs when no hysteresis is implemented in the transition conditions for
    continuous variables.

    As a result states constantly change due to over compensation of the
    behaviour of the activated state.

\end{description}

\subsection{Hierarchical FSMs}

Applying a hierarchy to the states of an FSM can simplify the set of transitions
and overall structure of the FSM.

Divide groups of states that correspond to a single NPC behaviour into their own
parent states.

Transition conditions for each active state in the hierarchy must be checked.

\section{Path Finding}
\label{sec:path_finding}

TODO

\section{Fluid Dynamics}
\label{sec:fluid_dynamics}

TODO

\section{Particles}
\label{sec:particles}

TODO

\end{document}
