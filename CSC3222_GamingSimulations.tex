\documentclass[a4paper]{article}
\def\DOCTITLE{CSC3222 Gaming Simulations}
\input{sections/preamble.tex}

\begin{document}

\tableofcontents

\section{Equations and their Solutions}

\subsection{Newton's First Law}

\textit{When viewed in an inertial reference frame, an object is either at rest
or moves at a constant velocity, unless acted upon by an external force.}

\begin{itemize}
  \item
    Objects in a scene that are to be kept in a constant position (e.g. ground)
    should be immune to physics calculations.

  \item
    Movable objects should have a "rest" state in which no physics calculations
    are performed for that object until something will cause it to move.

    This both makes the simulation less computationally intensive and reduced
    the chance of jitter and error caused by two nearly equal floating point
    numbers.
\end{itemize}

\subsection{Newton's Second Law}

\textit{The vector sum of the forces acting on an object is equal to the total
mass of that object multiplied by the acceleration of the object.}

\[
  F = ma
\]

\subsection{Newton's Third Law}

\textit{When one body exerts a force on a second body, the second body
simultaniously exerts a force equal in magnitude and opposite in direction to
that of the first body.}

\subsection{Law of Conservation of Momentum}

\textit{In a closed system, total momentum is consistent.}

\[
  p = mv
\]

Ignoring all other forces if two objects of mass $m_{n}$ travelling towards each
other with momentum $u_{n}$, the total momentum of the system is:
\[
  p_{initial} = m_{1}u_{1} + m_{2}u_{2}
\]

After they collide the two objects will have two new velocities while keeping
the same masses:
\begin{align*}
  p_{final} &= m_{1}v_{1} + m_{2}v_{2} \\
  p_{final} &= p_{initial}
\end{align*}

\subsection{SUVAT equations}

\begin{description}
  \item[$s$] Displacement
  \item[$u$] Initial velocity
  \item[$v$] Final velocity
  \item[$a$] Acceleration
  \item[$t$] Time
\end{description}

\begin{align*}
      v &= u + at \\
      s &= ut + \frac{1}{2}at^{2} \\
      s &= \frac{1}{2} \left(u + v\right) t \\
  v^{2} &= u^{2} + 2as \\
      s &= vt - \frac{1}{2}at^{2}
\end{align*}

Constant acceleration is assumed, this is not an issue in simulation as updates
are calculated in time steps sufficiently small that constant acceleration can
be assumed.

\subsection{Numerical Integration}

Using time step: $\Delta t = t_{x + 1} - t_{x}$

\subsubsection{Explicit Euler}

\begin{itemize}
  \item Simple
  \item Computationally cheap
  \item Unstable at high $\Delta t$
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x} \Delta t
\end{align*}

\subsubsection{Implicit Euler}

\begin{itemize}
  \item Similar to explicit Euler but uses rate of change in next state
  \item Stable
  \item Computationally expensive
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x + 1} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t
\end{align*}

\subsubsection{Semi-implicit Euler}

\begin{itemize}
  \item A combination of explicit and implicit Euler
  \item Stable
  \item Avoid expensive operations
\end{itemize}

\begin{align*}
  v_{x + 1} &= v_{x} + a_{x} \Delta t \\
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t
\end{align*}

\subsubsection{Verlet}

\begin{itemize}
  \item Similar computational cost to Semi-implicit Euler
  \item Entities must store their historical positions (in a FIFO buffer)
  \item Reversible
\end{itemize}

Substitute $v = u + at$ into Euler equations:
\begin{align*}
  s_{x + 1} &= s_{x} + v_{x + 1} \Delta t \\
            &= s_{x} + (v_{x} + a_{x} \Delta t) \Delta t \\
            &= s_{x} + v_{x} \Delta t + a_{x} \Delta t^{2}
\end{align*}

This can be solved for $v_{x}$ using the past two displacements:
\begin{align*}
  v_{x} &= \frac{s_{x} - s_{x - 1}}{\Delta t}
\end{align*}

The substituted back into:
\begin{align*}
  s_{x + 1} &= s_{x} + v_{x} \Delta t + a_{x} \Delta t^{2} \\
            &= s_{x} + (s_{x} - s_{x - 1}) + a_{x} \Delta t^{2}
\end{align*}

\subsection{Drag}

In simple simulations the forces that act against an object to eventually bring
it to a stop (e.g. friction, air resistance, etc.) can be represented by a
damping factor $0 < d < 1$.

This factor is used to attenuate the velocity of a moving entity in each physics
frame.

This factor can be varied as a cheap way of simulating different environments.

\subsection{Rest}

When the velocity of an entity is close to zero, set the velocity to zero.

This is done to avoid excessive computation for entities at rest.

\subsection{Gravity}

Gravity is simple to handle as a constant that is added to acceleration in the
$y$ axis.

This constant can be varied as a cheap way of simulating different environments.

\section{Collision Detection and Response}

\subsection{Detection}

Collision detection is a naturally expensive operation for scenes with large
numbers of entities.

Without optimisation it becomes an $N^{2}$ problem (where $N$ is the number of
entities).

An approach to reducing the number of comparison operations is to separate
collision detection into two phases: broadphase and narrowphase.

\subsubsection{Broadphase}

Broadphase collision detection reduces the number of collision checks required
by culling checks for entities that cannot have collided.

\Para{Bounding Box Test}

Tests for collisions using a bounding box defined by the extremes of an entity
in each axis.

In the case where there is no other entity "close" to the one being tested, this
replaces the complex collision check with a much simpler one.

Works well in scenes with low numbers of entities.

\Para{World Partitioning}

Partition the world into several subsections, converting the large $N^{2}$
problem into several smaller $n^{2}$ problems.

Provision has to be made for an entity to exist in multiple partitions if it is
on a boundary.

Entities are sorted into partitions based on their size and position.

If performing a simple geographical division then it is possible for the
distribution of entities to mean this is no faster (or sometimes slower) than
performing a bounding box check (e.g. if all entities are in the same
partition).

\Para{Binary Search Partitioning}

Binary search partitioning (BSP) solves the problem of uneven entity
distribution in world partitioning by recursively subdividing partitions based
on the number of entities in a partition.

An Octree is a common approach to this in which the world is split into
progressively smaller cubes.

The world is split into several partitions, if the number of entities in a
partition is above a set threshold then the partition is split into several sub
partitions. This process repeats until the number of entities in each sub
partition is below the set threshold.

The threshold must be chosen well: too high and the benefits of BSP are not
visible, too low and the process becomes inefficient due to the number of
sorting operations when partitions are divided.

\Para{Sort and Sweep}

Sort and sweep can be used in conjunction with any other method of culling
checks where collision is impossible.

In this process bounding boxes of all entities are projected onto a single axis
and any pairs of entities that do not overlap are culled from more expensive
comparisons.

This can be performed during the test for partition occupancy in world
partitioning or BSP.

\subsubsection{Narrowphase}

Accurately check the remaining pairs of entities.

Narrowphase checks should also provide the necessary data to calculate the
collision response:

\begin{description}
  \item[Contact point: $P$] \hfill \\
    Point at which the interface was detected.
  \item[Contact normal: $N$] \hfill \\
    A unit vector describing the direction in which the entities must be moved
    to resolve the interface.
  \item[Penetration depth: $p$] \hfill \\
    The minimum distance the entities must be moved to resolve the interface,
    i.e. the distance required for them to be touching, not intersecting.
\end{description}

Due to the mature of the time stepped physics model, entities will intersect
(interface) before they are detected. i.e. Collisions are not detected,
intersections are.

The time step must be small enough such that the contact point is on the correct
side of both entities, otherwise the interface will be resolved in the opposite
direction.

\Para{Sphere-Sphere detection}

Two spheres are said to have collided if the following equation is true:
\[
  d < r_{1} + r_{2}
\]

Where $d$ is the distance between the centres of the spheres and $r_{1}$ and
$r_{2}$ are the radii of each sphere.

The collision response data can be extracted as follows:
\begin{align*}
  p &= r_{1} + r_{2} - d \\
  N &= |S_{1} - S_{2}| \\
  P &= S_{1} - N \times (r_{1} - p)
\end{align*}

\Para{Sphere-Plane detection}

A sphere and plane are said to have collided if the following equation is true:
\[
  N \cdot S + d < r
\]

Where $N$ is the normal to the plane, $S$ is the position of the sphere, $d$ is
the distance from the plane to the world origin and $r$ is the radius of the
sphere.

The collision response data can be extracted as follows:
\begin{align*}
  p &= r - (N \cdot S + d) \\
  P &= S - N \times (r - p)
\end{align*}

Note that in this case an infinite plane is assumed.

\subsection{Response}

TODO

\section{Newtonian Physics}

TODO

\section{Springs}

TODO

\section{Fluid Dynamics}

TODO

\section{Particles}

TODO

\section{Path Finding}

TODO

\section{Choice and States}

TODO

\end{document}
